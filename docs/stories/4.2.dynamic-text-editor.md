# Story 4.2: Dynamic Text Editor

## Status
Ready for Development

## Story
**As a** content creator,
**I want** a dynamic text editor that can mix static content with executable code sections,
**so that** I can create documents with calculated values and dynamic content.

## Acceptance Criteria
1. Support for static and dynamic sections
2. Code editor for JavaScript expressions in dynamic sections
3. Live preview of rendered content
4. Variable interpolation in text
5. Test case management for dynamic sections
6. Syntax highlighting for code sections
7. Error handling for invalid expressions

## Tasks / Subtasks
- [ ] **Task 1: Create Section Data Model** (AC: 1)
  - [ ] Define Section types at `src/entities/section/types/index.ts`
  - [ ] Create static section interface
  - [ ] Create dynamic section interface with code content
  - [ ] Define test case structure for validation
  - [ ] Implement section ordering and management

- [ ] **Task 2: Build Editor Layout Component** (AC: 1, 3)
  - [ ] Create DynamicTextEditor component at `src/features/text-editor/ui/DynamicTextEditor.tsx`
  - [ ] Implement split-pane layout (editor/preview)
  - [ ] Add section list/navigator sidebar
  - [ ] Create toolbar for editor actions
  - [ ] Style with Material UI components

- [ ] **Task 3: Implement Static Text Editing** (AC: 1)
  - [ ] Create StaticSection component at `src/features/text-editor/ui/StaticSection.tsx`
  - [ ] Implement rich text editing (using a library like Slate or Draft.js)
  - [ ] Add formatting toolbar (bold, italic, lists, etc.)
  - [ ] Support markdown syntax
  - [ ] Handle paste and drag-drop

- [ ] **Task 4: Build Code Editor for Dynamic Sections** (AC: 2, 6)
  - [ ] Create DynamicSection component at `src/features/text-editor/ui/DynamicSection.tsx`
  - [ ] Integrate code editor (Monaco Editor or CodeMirror)
  - [ ] Configure JavaScript syntax highlighting
  - [ ] Add code completion for available variables
  - [ ] Implement code folding and formatting
  - [ ] Add line numbers and error indicators

- [ ] **Task 5: Implement Expression Evaluation** (AC: 4, 7)
  - [ ] Create evaluation service at `src/features/text-editor/lib/evaluator.ts`
  - [ ] Implement safe JavaScript evaluation (sandboxed)
  - [ ] Support variable interpolation syntax (e.g., ${variable})
  - [ ] Handle TPN calculation context (MockMe interface)
  - [ ] Catch and display evaluation errors
  - [ ] Implement timeout for long-running code

- [ ] **Task 6: Create Live Preview System** (AC: 3)
  - [ ] Create Preview component at `src/features/text-editor/ui/Preview.tsx`
  - [ ] Render static sections as HTML
  - [ ] Execute and display dynamic section results
  - [ ] Update preview on content changes (debounced)
  - [ ] Show error states in preview
  - [ ] Support print-friendly preview

- [ ] **Task 7: Implement Test Case Management** (AC: 5)
  - [ ] Create TestCaseEditor component at `src/features/text-editor/ui/TestCaseEditor.tsx`
  - [ ] Add/edit/delete test cases for dynamic sections
  - [ ] Define test variables and expected outputs
  - [ ] Support different match types (exact, contains, regex)
  - [ ] Run tests and display results
  - [ ] Visual indicators for passing/failing tests

- [ ] **Task 8: Build Redux Integration** (AC: All)
  - [ ] Create editor slice at `src/features/text-editor/model/editorSlice.ts`
  - [ ] Manage sections array in state
  - [ ] Track active section and cursor position
  - [ ] Handle undo/redo functionality
  - [ ] Store test results
  - [ ] Implement auto-save

- [ ] **Task 9: Write Tests** (AC: All)
  - [ ] Unit tests for expression evaluation
  - [ ] Test section CRUD operations
  - [ ] Test variable interpolation
  - [ ] Test error handling
  - [ ] Integration tests for editor workflow
  - [ ] E2E tests for complete editing session

## Dev Notes

### Previous Story Context
From Story 4.1:
- TPN calculation context (MockMe) available
- Variable system established for calculations
- Can use TPN values in dynamic sections

### Section Structure
```typescript
interface Section {
  id: number;
  type: 'static' | 'dynamic';
  name: string;
  content: string; // HTML for static, JS code for dynamic
  testCases?: TestCase[];
  order: number;
}

interface TestCase {
  name: string;
  variables: Record<string, any>;
  expected: string;
  matchType: 'exact' | 'contains' | 'regex' | 'styles';
  expectedStyles?: Record<string, any>;
}
```

### Dynamic Section Evaluation Pattern
```typescript
// Safe evaluation using Function constructor
function evaluateDynamicSection(
  code: string,
  context: Record<string, any>
): string {
  try {
    // Create sandboxed function
    const func = new Function(...Object.keys(context), `
      'use strict';
      ${code}
    `);
    
    // Execute with context values
    const result = func(...Object.values(context));
    
    // Convert result to string for display
    return String(result);
  } catch (error) {
    return `Error: ${error.message}`;
  }
}
```

### Variable Interpolation
```typescript
// Support ${variable} syntax in text
function interpolateVariables(
  text: string,
  variables: Record<string, any>
): string {
  return text.replace(/\${(\w+)}/g, (match, key) => {
    return variables[key] !== undefined ? String(variables[key]) : match;
  });
}
```

### Editor Libraries Options

**For Rich Text (Static Sections):**
1. **Slate.js** - Highly customizable, React-based
2. **Draft.js** - Facebook's rich text framework
3. **Quill** - Full-featured with good defaults

**For Code Editor (Dynamic Sections):**
1. **Monaco Editor** - VSCode's editor (feature-rich but larger)
2. **CodeMirror 6** - Lighter weight, good performance
3. **Ace Editor** - Battle-tested, many language modes

Recommendation: Slate.js + CodeMirror 6 for balance of features and bundle size

### Test Execution Pattern
```typescript
interface TestResult {
  passed: boolean;
  actual: string;
  expected: string;
  error?: string;
}

function runTestCase(
  section: Section,
  testCase: TestCase
): TestResult {
  try {
    const actual = evaluateDynamicSection(
      section.content,
      testCase.variables
    );
    
    const passed = matchOutput(
      actual,
      testCase.expected,
      testCase.matchType
    );
    
    return { passed, actual, expected: testCase.expected };
  } catch (error) {
    return {
      passed: false,
      actual: '',
      expected: testCase.expected,
      error: error.message
    };
  }
}

function matchOutput(
  actual: string,
  expected: string,
  matchType: 'exact' | 'contains' | 'regex'
): boolean {
  switch (matchType) {
    case 'exact':
      return actual === expected;
    case 'contains':
      return actual.includes(expected);
    case 'regex':
      return new RegExp(expected).test(actual);
    default:
      return false;
  }
}
```

### Redux State Structure
```typescript
interface EditorState {
  sections: Section[];
  activeSection: number | null;
  isDirty: boolean;
  testResults: Record<number, TestResult[]>;
  previewMode: 'side-by-side' | 'preview-only' | 'editor-only';
  undoStack: Section[][];
  redoStack: Section[][];
}
```

### Auto-save Strategy
```typescript
// Debounced auto-save to Firestore
const autoSave = debounce(async (sections: Section[]) => {
  try {
    await updateDoc(doc(db, 'documents', documentId), {
      sections,
      updatedAt: serverTimestamp()
    });
  } catch (error) {
    console.error('Auto-save failed:', error);
  }
}, 2000); // 2 second delay
```

### Security Considerations
- Sanitize HTML output from static sections
- Sandbox JavaScript execution in dynamic sections
- Prevent access to window/document objects
- Timeout long-running scripts
- Validate all user input

### Testing Requirements

#### Testing Standards
From [Source: architecture/testing-strategy.md]:
- Test expression evaluation with various inputs
- Test section CRUD operations
- Verify test case execution
- Test error handling and recovery
- Integration tests for complete editing flows

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-09-05 | 1.0 | Initial story creation | Scrum Master |

## Dev Agent Record

### Agent Model Used
_To be populated by dev agent_

### Debug Log References
_To be populated by dev agent_

### Completion Notes List
_To be populated by dev agent_

### File List
_To be populated by dev agent_

## QA Results
_To be populated by QA agent_