# Story 5.2: Shared Ingredient Management

## Status
Ready for Development

## Story
**As a** healthcare organization administrator,
**I want** to manage shared ingredients across multiple references and users,
**so that** we can maintain consistency, reduce duplication, and enable collaborative ingredient management.

## Acceptance Criteria
1. Shared ingredient repository system
2. Deduplication detection and management
3. Reference counting for ingredient usage
4. Sync shared ingredients across references
5. Conflict resolution for concurrent modifications
6. Master/custom ingredient relationships
7. Permission-based sharing controls
8. Bulk migration to shared ingredients

## Tasks / Subtasks
- [ ] **Task 1: Create Shared Ingredient Model** (AC: 1, 6)
  - [ ] Define SharedIngredient interface at `src/entities/shared-ingredient/types/index.ts`
  - [ ] Create master ingredient structure
  - [ ] Define custom override fields
  - [ ] Add sharing metadata
  - [ ] Create reference tracking model
  - [ ] Define permission levels

- [ ] **Task 2: Build Deduplication Service** (AC: 2)
  - [ ] Create deduplication service at `src/features/shared-ingredients/lib/deduplicationService.ts`
  - [ ] Implement content hashing for comparison
  - [ ] Add fuzzy matching for similar ingredients
  - [ ] Create duplicate detection algorithm
  - [ ] Build merge suggestion engine
  - [ ] Generate deduplication reports

- [ ] **Task 3: Implement Reference Counting** (AC: 3)
  - [ ] Create reference service at `src/features/shared-ingredients/lib/referenceCountingService.ts`
  - [ ] Track ingredient usage across documents
  - [ ] Update counts on add/remove
  - [ ] Prevent deletion of referenced ingredients
  - [ ] Create usage analytics
  - [ ] Build orphan detection

- [ ] **Task 4: Build Synchronization System** (AC: 4)
  - [ ] Create sync service at `src/features/shared-ingredients/lib/syncService.ts`
  - [ ] Implement real-time sync with Firestore
  - [ ] Handle offline/online transitions
  - [ ] Create sync conflict detection
  - [ ] Build incremental sync
  - [ ] Add sync status tracking

- [ ] **Task 5: Implement Conflict Resolution** (AC: 5)
  - [ ] Create conflict resolver at `src/features/shared-ingredients/lib/conflictResolver.ts`
  - [ ] Detect concurrent modifications
  - [ ] Implement three-way merge for ingredients
  - [ ] Create conflict UI workflows
  - [ ] Build auto-resolution rules
  - [ ] Add conflict history tracking

- [ ] **Task 6: Create Permission System** (AC: 7)
  - [ ] Build permission service at `src/features/shared-ingredients/lib/permissionService.ts`
  - [ ] Define permission levels (view, edit, admin)
  - [ ] Implement role-based access control
  - [ ] Create sharing workflows
  - [ ] Add audit logging
  - [ ] Build permission inheritance

- [ ] **Task 7: Build Migration Tools** (AC: 8)
  - [ ] Create migration service at `src/features/shared-ingredients/lib/migrationService.ts`
  - [ ] Implement bulk conversion to shared
  - [ ] Create rollback capability
  - [ ] Build migration preview
  - [ ] Add progress tracking
  - [ ] Generate migration reports

- [ ] **Task 8: Create Redux Integration** (AC: All)
  - [ ] Create shared ingredient slice at `src/features/shared-ingredients/model/sharedIngredientSlice.ts`
  - [ ] Manage shared repository in state
  - [ ] Track local overrides
  - [ ] Handle sync status
  - [ ] Store conflict information
  - [ ] Create selectors for shared data

- [ ] **Task 9: Build UI Components** (AC: 1, 2, 5, 8)
  - [ ] Create SharedIngredientManager at `src/features/shared-ingredients/ui/SharedIngredientManager.tsx`
  - [ ] Build DuplicateReportModal for deduplication
  - [ ] Create ConflictResolutionDialog
  - [ ] Add SharingPermissionsPanel
  - [ ] Build MigrationWizard component
  - [ ] Create UsageAnalytics dashboard

- [ ] **Task 10: Write Tests** (AC: All)
  - [ ] Unit tests for deduplication logic
  - [ ] Test reference counting accuracy
  - [ ] Test sync mechanisms
  - [ ] Test conflict resolution
  - [ ] Test permission enforcement
  - [ ] Integration tests for workflows
  - [ ] E2E tests for sharing scenarios

## Dev Notes

### Previous Story Context
From Story 4.5 (Ingredient Management):
- Basic ingredient CRUD operations
- Ingredient structure and validation
- Need to extend for sharing

From Story 5.1 (Version History):
- Version tracking for shared ingredients
- Change attribution important for collaboration

### Architecture References

#### Tech Stack [Source: architecture/tech-stack.md]
- Firebase Firestore for shared repository
- Real-time sync capabilities
- Redux Toolkit for state management

#### Project Structure [Source: architecture/source-tree.md]
- Shared ingredients feature: `/src/features/shared-ingredients/`
- Shared ingredient entity: `/src/entities/shared-ingredient/`
- Follow FSD layer dependencies

### Parent Project Shared Ingredient Structure
From `../dynamic-text/src/lib/SharedIngredientManager.svelte`:
```typescript
interface SharedIngredient {
  id: string;
  masterId: string;
  name: string;
  keyname: string;
  type: IngredientType;
  referenceRanges: ReferenceRange[];
  metadata: {
    createdBy: string;
    createdAt: Date;
    modifiedBy: string;
    modifiedAt: Date;
    version: number;
    isPublic: boolean;
    organizationId?: string;
  };
  usage: {
    referenceCount: number;
    lastUsed: Date;
    references: Array<{
      id: string;
      name: string;
      type: string;
    }>;
  };
  customizations?: Array<{
    referenceId: string;
    overrides: Partial<Ingredient>;
  }>;
}
```

### Deduplication Algorithm
```typescript
class DeduplicationService {
  detectDuplicates(ingredients: Ingredient[]): DuplicateGroup[] {
    const groups: DuplicateGroup[] = [];
    const processed = new Set<string>();
    
    for (let i = 0; i < ingredients.length; i++) {
      if (processed.has(ingredients[i].id)) continue;
      
      const duplicates = this.findSimilar(ingredients[i], ingredients.slice(i + 1));
      
      if (duplicates.length > 0) {
        groups.push({
          master: ingredients[i],
          duplicates: duplicates,
          similarity: this.calculateSimilarity(ingredients[i], duplicates),
          suggestion: this.generateMergeSuggestion(ingredients[i], duplicates)
        });
        
        duplicates.forEach(d => processed.add(d.id));
      }
      
      processed.add(ingredients[i].id);
    }
    
    return groups;
  }
  
  private findSimilar(target: Ingredient, candidates: Ingredient[]): Ingredient[] {
    return candidates.filter(candidate => {
      // Exact keyname match
      if (target.keyname === candidate.keyname) return true;
      
      // Similar name (fuzzy match)
      if (this.fuzzyMatch(target.name, candidate.name) > 0.8) return true;
      
      // Content hash match
      if (this.contentHash(target) === this.contentHash(candidate)) return true;
      
      return false;
    });
  }
  
  private contentHash(ingredient: Ingredient): string {
    // Create hash from significant fields
    const significant = {
      type: ingredient.type,
      ranges: ingredient.referenceRanges,
      unit: ingredient.unit
    };
    
    return crypto.createHash('md5')
      .update(JSON.stringify(significant))
      .digest('hex');
  }
}
```

### Reference Counting Implementation
```typescript
class ReferenceCountingService {
  async updateReferenceCount(ingredientId: string): Promise<void> {
    // Count all references
    const referencesQuery = query(
      collection(db, 'references'),
      where('ingredientIds', 'array-contains', ingredientId)
    );
    
    const snapshot = await getDocs(referencesQuery);
    const count = snapshot.size;
    
    // Update the count
    await updateDoc(doc(db, 'sharedIngredients', ingredientId), {
      'usage.referenceCount': count,
      'usage.lastUsed': serverTimestamp(),
      'usage.references': snapshot.docs.map(doc => ({
        id: doc.id,
        name: doc.data().name,
        type: doc.data().type
      }))
    });
  }
  
  async canDelete(ingredientId: string): Promise<boolean> {
    const ingredient = await getDoc(doc(db, 'sharedIngredients', ingredientId));
    return ingredient.data()?.usage?.referenceCount === 0;
  }
  
  async findOrphans(): Promise<string[]> {
    const ingredientsQuery = query(
      collection(db, 'sharedIngredients'),
      where('usage.referenceCount', '==', 0)
    );
    
    const snapshot = await getDocs(ingredientsQuery);
    return snapshot.docs.map(doc => doc.id);
  }
}
```

### Synchronization Pattern
```typescript
class SyncService {
  private syncQueue: SyncOperation[] = [];
  private syncInProgress = false;
  
  async syncSharedIngredient(ingredientId: string, changes: Partial<SharedIngredient>): Promise<void> {
    // Add to queue
    this.syncQueue.push({
      id: ingredientId,
      changes,
      timestamp: Date.now(),
      retries: 0
    });
    
    // Process queue
    if (!this.syncInProgress) {
      await this.processQueue();
    }
  }
  
  private async processQueue(): Promise<void> {
    this.syncInProgress = true;
    
    while (this.syncQueue.length > 0) {
      const operation = this.syncQueue.shift()!;
      
      try {
        // Check for conflicts
        const current = await getDoc(doc(db, 'sharedIngredients', operation.id));
        const serverVersion = current.data()?.metadata?.version || 0;
        const localVersion = operation.changes.metadata?.version || 0;
        
        if (serverVersion > localVersion) {
          // Conflict detected
          await this.handleConflict(operation, current.data());
        } else {
          // Apply changes
          await updateDoc(doc(db, 'sharedIngredients', operation.id), {
            ...operation.changes,
            'metadata.version': increment(1)
          });
        }
      } catch (error) {
        // Retry logic
        if (operation.retries < 3) {
          operation.retries++;
          this.syncQueue.push(operation);
        } else {
          console.error('Sync failed after retries:', error);
        }
      }
    }
    
    this.syncInProgress = false;
  }
}
```

### Conflict Resolution UI
```typescript
const ConflictResolutionDialog: React.FC<{
  localIngredient: SharedIngredient;
  serverIngredient: SharedIngredient;
  onResolve: (resolved: SharedIngredient) => void;
}> = ({ localIngredient, serverIngredient, onResolve }) => {
  const [resolution, setResolution] = useState<'local' | 'server' | 'merge'>('merge');
  const [mergedIngredient, setMergedIngredient] = useState<SharedIngredient>();
  
  const autoMerge = () => {
    // Attempt automatic merge
    const merged = {
      ...serverIngredient,
      // Take newer reference ranges
      referenceRanges: [
        ...serverIngredient.referenceRanges,
        ...localIngredient.referenceRanges.filter(
          lr => !serverIngredient.referenceRanges.find(
            sr => sr.populationType === lr.populationType
          )
        )
      ],
      // Combine customizations
      customizations: [
        ...(serverIngredient.customizations || []),
        ...(localIngredient.customizations || [])
      ].filter((c, i, arr) => 
        arr.findIndex(x => x.referenceId === c.referenceId) === i
      )
    };
    
    setMergedIngredient(merged);
  };
  
  return (
    <Dialog open={true} maxWidth="lg">
      <DialogTitle>Resolve Ingredient Conflict</DialogTitle>
      <DialogContent>
        <Grid container spacing={2}>
          <Grid item xs={4}>
            <Paper elevation={2} sx={{ p: 2 }}>
              <Typography variant="h6">Your Version</Typography>
              <IngredientDisplay ingredient={localIngredient} />
              <Button 
                variant={resolution === 'local' ? 'contained' : 'outlined'}
                onClick={() => setResolution('local')}
              >
                Use This Version
              </Button>
            </Paper>
          </Grid>
          
          <Grid item xs={4}>
            <Paper elevation={2} sx={{ p: 2 }}>
              <Typography variant="h6">Server Version</Typography>
              <IngredientDisplay ingredient={serverIngredient} />
              <Button 
                variant={resolution === 'server' ? 'contained' : 'outlined'}
                onClick={() => setResolution('server')}
              >
                Use This Version
              </Button>
            </Paper>
          </Grid>
          
          <Grid item xs={4}>
            <Paper elevation={2} sx={{ p: 2 }}>
              <Typography variant="h6">Merged Version</Typography>
              {mergedIngredient && <IngredientDisplay ingredient={mergedIngredient} />}
              <Button 
                variant={resolution === 'merge' ? 'contained' : 'outlined'}
                onClick={() => {
                  autoMerge();
                  setResolution('merge');
                }}
              >
                Auto-Merge
              </Button>
            </Paper>
          </Grid>
        </Grid>
      </DialogContent>
      <DialogActions>
        <Button onClick={() => {
          const resolved = resolution === 'local' ? localIngredient :
                          resolution === 'server' ? serverIngredient :
                          mergedIngredient!;
          onResolve(resolved);
        }}>
          Apply Resolution
        </Button>
      </DialogActions>
    </Dialog>
  );
};
```

### Permission Management
```typescript
interface IngredientPermissions {
  view: string[];    // User IDs or role names
  edit: string[];
  admin: string[];
  inherit: boolean;  // Inherit from organization
}

class PermissionService {
  async checkPermission(
    ingredientId: string, 
    userId: string, 
    action: 'view' | 'edit' | 'admin'
  ): Promise<boolean> {
    const ingredient = await getDoc(doc(db, 'sharedIngredients', ingredientId));
    const permissions = ingredient.data()?.permissions as IngredientPermissions;
    
    if (!permissions) return false;
    
    // Check direct permission
    if (permissions[action].includes(userId)) return true;
    
    // Check role-based permission
    const userRoles = await this.getUserRoles(userId);
    if (userRoles.some(role => permissions[action].includes(role))) return true;
    
    // Check organization permission if inheriting
    if (permissions.inherit) {
      return this.checkOrganizationPermission(
        ingredient.data()?.metadata?.organizationId,
        userId,
        action
      );
    }
    
    return false;
  }
}
```

### Migration Wizard Pattern
```typescript
const MigrationWizard: React.FC = () => {
  const [step, setStep] = useState(0);
  const [selection, setSelection] = useState<Ingredient[]>([]);
  const [preview, setPreview] = useState<MigrationPreview>();
  
  const steps = [
    'Select Ingredients',
    'Review Duplicates',
    'Set Permissions',
    'Preview Changes',
    'Execute Migration'
  ];
  
  const generatePreview = async () => {
    const preview = await migrationService.preview(selection);
    setPreview(preview);
  };
  
  const executeMigration = async () => {
    const result = await migrationService.migrate(selection, {
      deduplication: true,
      preserveCustomizations: true,
      updateReferences: true
    });
    
    if (result.success) {
      // Show success report
    } else {
      // Show errors and rollback option
    }
  };
  
  return (
    <Stepper activeStep={step}>
      {steps.map(label => (
        <Step key={label}>
          <StepLabel>{label}</StepLabel>
        </Step>
      ))}
    </Stepper>
  );
};
```

### Performance Considerations
- Index ingredient keynames and names
- Cache deduplication results
- Batch sync operations
- Use transactions for reference counting
- Implement pagination for large lists
- Debounce conflict checks

### Security Considerations
- Validate permissions on all operations
- Audit log all sharing changes
- Encrypt sensitive ingredient data
- Rate limit bulk operations
- Verify organization boundaries

### Testing Requirements

#### Testing Standards [Source: architecture/testing-strategy.md]
- Test deduplication accuracy
- Test reference counting reliability
- Test sync conflict resolution
- Test permission enforcement

#### Key Test Scenarios
- Detect duplicates in 1000+ ingredients
- Update reference counts correctly
- Resolve sync conflicts properly
- Enforce permissions accurately
- Migrate 100+ ingredients successfully
- Handle offline/online transitions
- Test concurrent modifications

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-05 | 1.0 | Initial story creation | Scrum Master |

## Dev Agent Record

### Agent Model Used
_To be populated by dev agent_

### Debug Log References
_To be populated by dev agent_

### Completion Notes List
_To be populated by dev agent_

### File List
_To be populated by dev agent_

## QA Results
_To be populated by QA agent_