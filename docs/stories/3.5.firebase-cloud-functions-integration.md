# Story 3.5: Firebase Cloud Functions Integration

## Status
Ready for Development

## Story
**As a** developer,
**I want** Cloud Functions integrated for server-side operations,
**so that** complex business logic and secure operations run in a trusted environment.

## Acceptance Criteria
1. Cloud Functions SDK configured for callable functions
2. Existing Cloud Functions from Svelte app remain compatible
3. Error handling for function invocations
4. Loading states during function execution
5. Retry logic for transient failures
6. TypeScript types for function parameters and responses
7. Local emulator support for development

## Tasks / Subtasks
- [ ] **Task 1: Initialize Cloud Functions SDK** (AC: 1, 7)
  - [ ] Install Firebase Functions SDK if not already installed
  - [ ] Configure Functions in `src/shared/config/firebase.ts`
  - [ ] Set up Functions emulator for local development
  - [ ] Configure functions region if needed
  - [ ] Test connection to existing Cloud Functions

- [ ] **Task 2: Create Functions Service Layer** (AC: 1, 3, 5)
  - [ ] Create functions service at `src/shared/lib/firebase/functionsService.ts`
  - [ ] Implement callable function wrapper
  - [ ] Add error handling and error code mapping
  - [ ] Implement retry logic with exponential backoff
  - [ ] Create helper functions for common operations
  - [ ] Handle timeout scenarios

- [ ] **Task 3: Define TypeScript Types** (AC: 6)
  - [ ] Create types for function parameters at `src/shared/types/functions/`
  - [ ] Define response types for each Cloud Function
  - [ ] Create error types for function failures
  - [ ] Ensure type safety for all function calls
  - [ ] Document expected inputs/outputs

- [ ] **Task 4: Create Redux Integration** (AC: 4)
  - [ ] Create functions slice at `src/features/functions/model/functionsSlice.ts`
  - [ ] Track loading states for function calls
  - [ ] Store function results in Redux where appropriate
  - [ ] Implement error state management
  - [ ] Create selectors for function status

- [ ] **Task 5: Implement Existing Functions** (AC: 2)
  - [ ] List all Cloud Functions from Svelte app
  - [ ] Create client-side wrappers for each function
  - [ ] Ensure parameter compatibility
  - [ ] Test each function with existing data
  - [ ] Document any breaking changes

- [ ] **Task 6: Build Function UI Feedback** (AC: 4)
  - [ ] Create loading indicators for function calls
  - [ ] Implement progress feedback for long-running functions
  - [ ] Build error notification system
  - [ ] Add success confirmations
  - [ ] Create function status component

- [ ] **Task 7: Set Up Development Environment** (AC: 7)
  - [ ] Configure Firebase emulators suite
  - [ ] Create local function stubs for testing
  - [ ] Set up emulator UI access
  - [ ] Document emulator setup process
  - [ ] Create development function triggers

- [ ] **Task 8: Write Tests** (AC: All)
  - [ ] Unit tests for function service layer
  - [ ] Integration tests with emulated functions
  - [ ] Test retry logic and error handling
  - [ ] Test loading state management
  - [ ] Mock function responses for component tests

## Dev Notes

### Previous Story Insights
From Stories 3.1-3.4:
- Firebase configured without authentication
- No user context needed (anonymous or public functions)
- Redux established for state management
- Error handling patterns established

### Cloud Functions Configuration
Basic Functions setup without authentication:
```typescript
import { getFunctions, httpsCallable, connectFunctionsEmulator } from 'firebase/functions';

const functions = getFunctions();

// Connect to emulator in development
if (process.env.NODE_ENV === 'development') {
  connectFunctionsEmulator(functions, 'localhost', 5001);
}

// Call a function without auth context
export async function callFunction<T, R>(
  functionName: string,
  data: T
): Promise<R> {
  const callable = httpsCallable<T, R>(functions, functionName);
  
  try {
    const result = await callable(data);
    return result.data;
  } catch (error: any) {
    console.error(`Function ${functionName} failed:`, error);
    throw new Error(error.message || 'Function call failed');
  }
}
```

### Existing Cloud Functions (from Svelte app)
Document which functions exist and their purposes:
```typescript
// Example function signatures to implement
interface CloudFunctions {
  // TPN calculation functions
  calculateTPNValues: (data: TPNInput) => Promise<TPNResult>;
  validateIngredients: (ingredients: Ingredient[]) => Promise<ValidationResult>;
  
  // Document processing
  generatePDF: (documentId: string) => Promise<{ url: string }>;
  exportData: (format: 'csv' | 'json') => Promise<{ url: string }>;
  
  // AI/ML functions (if any)
  generateTestCases: (section: Section) => Promise<TestCase[]>;
  getRecommendations: (context: any) => Promise<Recommendation[]>;
}
```

### Error Handling Strategy
```typescript
enum FunctionErrorCode {
  UNAUTHENTICATED = 'unauthenticated', // Won't occur with no auth
  INVALID_ARGUMENT = 'invalid-argument',
  DEADLINE_EXCEEDED = 'deadline-exceeded',
  NOT_FOUND = 'not-found',
  ALREADY_EXISTS = 'already-exists',
  RESOURCE_EXHAUSTED = 'resource-exhausted',
  FAILED_PRECONDITION = 'failed-precondition',
  ABORTED = 'aborted',
  OUT_OF_RANGE = 'out-of-range',
  UNIMPLEMENTED = 'unimplemented',
  INTERNAL = 'internal',
  UNAVAILABLE = 'unavailable',
  DATA_LOSS = 'data-loss',
}

// Map error codes to user-friendly messages
const errorMessages: Record<string, string> = {
  'deadline-exceeded': 'Operation took too long. Please try again.',
  'resource-exhausted': 'Too many requests. Please wait and try again.',
  'unavailable': 'Service temporarily unavailable. Please try again later.',
  // ... more mappings
};
```

### Retry Logic Implementation
```typescript
async function callWithRetry<T, R>(
  fn: () => Promise<R>,
  maxRetries = 3,
  delayMs = 1000
): Promise<R> {
  for (let i = 0; i < maxRetries; i++) {
    try {
      return await fn();
    } catch (error: any) {
      const isRetryable = [
        'unavailable',
        'deadline-exceeded',
        'resource-exhausted'
      ].includes(error.code);
      
      if (!isRetryable || i === maxRetries - 1) {
        throw error;
      }
      
      await new Promise(resolve => 
        setTimeout(resolve, delayMs * Math.pow(2, i))
      );
    }
  }
  throw new Error('Max retries exceeded');
}
```

### Redux State Structure
```typescript
interface FunctionsState {
  loading: Record<string, boolean>;
  errors: Record<string, string | null>;
  results: Record<string, any>;
}

// Example usage in slice
const functionsSlice = createSlice({
  name: 'functions',
  initialState,
  reducers: {
    functionCallStart: (state, action) => {
      state.loading[action.payload.functionName] = true;
      state.errors[action.payload.functionName] = null;
    },
    functionCallSuccess: (state, action) => {
      state.loading[action.payload.functionName] = false;
      state.results[action.payload.functionName] = action.payload.result;
    },
    functionCallError: (state, action) => {
      state.loading[action.payload.functionName] = false;
      state.errors[action.payload.functionName] = action.payload.error;
    },
  },
});
```

### Local Development Setup
```bash
# Install Firebase tools globally
npm install -g firebase-tools

# Initialize emulators (one-time setup)
firebase init emulators

# Start emulators
firebase emulators:start

# Emulator UI available at http://localhost:4000
```

### Testing Requirements

#### Testing Standards
From [Source: architecture/testing-strategy.md]:
- Mock Cloud Functions for unit tests
- Use Functions emulator for integration tests
- Test retry logic with simulated failures
- Verify error handling for all error codes
- Test loading state transitions

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-09-05 | 1.0 | Initial story creation with no-auth approach | Scrum Master |

## Dev Agent Record

### Agent Model Used
_To be populated by dev agent_

### Debug Log References
_To be populated by dev agent_

### Completion Notes List
_To be populated by dev agent_

### File List
_To be populated by dev agent_

## QA Results
_To be populated by QA agent_